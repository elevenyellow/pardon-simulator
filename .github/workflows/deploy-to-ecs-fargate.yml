name: Deploy to ECS Fargate

on:
  push:
    branches: [main]
    paths:
      - 'coral-server/**'
      - 'agents/**'
      - '.github/workflows/deploy-to-ecs-fargate.yml'
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  ECS_CLUSTER: pardon-production
  ECS_SERVICE: pardon-app
  TASK_FAMILY: pardon-simulator

jobs:
  build-and-deploy:
    name: Build & Deploy to ECS
    runs-on: ubuntu-latest
    environment: 
      name: production
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
      
      - name: üîê Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: üîë Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: üè∑Ô∏è Set ECR registry from login
        run: |
          echo "ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}" >> $GITHUB_ENV
      
      - name: üè∑Ô∏è Generate image metadata
        id: meta
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          echo "tags=${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "üè∑Ô∏è  Image tag: ${SHORT_SHA}"
      
      - name: üèóÔ∏è Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      - name: üê≥ Build and push Coral Server (AMD64 for Fargate)
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ./coral-server/Dockerfile
          platforms: linux/amd64
          push: true
          tags: |
            ${{ env.ECR_REGISTRY }}/coral-server:${{ steps.meta.outputs.tags }}
            ${{ env.ECR_REGISTRY }}/coral-server:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
      
      - name: ü§ñ Build and push Pardon Agent (AMD64 for Fargate)
        uses: docker/build-push-action@v4
        with:
          context: ./agents
          file: ./agents/Dockerfile.agent.minimal
          platforms: linux/amd64
          push: true
          tags: |
            ${{ env.ECR_REGISTRY }}/pardon-agent:${{ steps.meta.outputs.tags }}
            ${{ env.ECR_REGISTRY }}/pardon-agent:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
      
      - name: ‚úÖ Build complete
        run: |
          echo "üéâ Images built and pushed successfully!"
          echo "Coral Server: ${{ steps.login-ecr.outputs.registry }}/coral-server:${{ steps.meta.outputs.tags }}"
          echo "Pardon Agent: ${{ steps.login-ecr.outputs.registry }}/pardon-agent:${{ steps.meta.outputs.tags }}"
      
      - name: üìã Update task definition with new images
        id: task-def
        run: |
          echo "üìã Fetching current task definition..."
          
          # Get the current task definition (without ARN, revision, etc.)
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition ${{ env.TASK_FAMILY }} \
            --region ${{ env.AWS_REGION }} \
            --query 'taskDefinition' \
            --output json)
          
          # Update image tags in the task definition
          NEW_TASK_DEF=$(echo "$TASK_DEF" | jq --arg TAG "${{ steps.meta.outputs.tags }}" --arg REGISTRY "${{ steps.login-ecr.outputs.registry }}" '
            .containerDefinitions |= map(
              if .name == "coral-server" then
                .image = $REGISTRY + "/coral-server:" + $TAG
              elif (.name | startswith("agent-")) then
                .image = $REGISTRY + "/pardon-agent:" + $TAG
              else . end
            ) |
            # Remove fields that cannot be included in registration
            del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)
          ')
          
          # Save to temporary file
          echo "$NEW_TASK_DEF" > /tmp/task-definition.json
          
          echo "üìã Registering new task definition..."
          TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file:///tmp/task-definition.json \
            --region ${{ env.AWS_REGION }} \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "task_arn=${TASK_DEF_ARN}" >> $GITHUB_OUTPUT
          echo "‚úÖ New task definition: ${TASK_DEF_ARN}"
      
      - name: üîÑ Update ECS service (rolling deployment)
        run: |
          echo "üîÑ Updating ECS service..."
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --task-definition ${{ env.TASK_FAMILY }} \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }} > /dev/null
          
          echo "‚úÖ Deployment initiated"
      
      - name: ‚è≥ Wait for deployment to stabilize
        run: |
          echo "‚è≥ Waiting for deployment to complete..."
          echo "   (This may take 3-5 minutes)"
          
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ Service is stable"
      
      - name: üìä Check service status
        run: |
          echo "üìä Checking service status..."
          
          RUNNING_COUNT=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].runningCount' \
            --output text)
          
          DESIRED_COUNT=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].desiredCount' \
            --output text)
          
          echo "‚úÖ Running tasks: ${RUNNING_COUNT}/${DESIRED_COUNT}"
      
      - name: üè• Health check
        run: |
          echo "üè• Getting ALB URL..."
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --query 'LoadBalancers[?contains(LoadBalancerName, `pardon-alb`)].DNSName' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          if [ -z "$ALB_DNS" ]; then
            echo "‚ö†Ô∏è  Could not find ALB, skipping health check"
            exit 0
          fi
          
          ALB_URL="http://${ALB_DNS}:5555"
          echo "Testing: ${ALB_URL}/health"
          
          # Wait a bit for tasks to be ready
          sleep 15
          
          # Try health check
          for i in {1..5}; do
            echo "Attempt $i/5..."
            if curl -sf "${ALB_URL}/health" > /dev/null; then
              echo "‚úÖ Health check PASSED!"
              curl -s "${ALB_URL}/health"
              exit 0
            fi
            echo "‚ö†Ô∏è  Health check not responding yet, retrying..."
            sleep 10
          done
          
          echo "‚ö†Ô∏è  Health check timeout (service may still be starting)"
          echo "   Manual check: curl ${ALB_URL}/health"
      
      - name: üì¢ Deployment summary
        if: always()
        run: |
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --query 'LoadBalancers[?contains(LoadBalancerName, `pardon-alb`)].DNSName' \
            --output text \
            --region ${{ env.AWS_REGION }} || echo "Not found")
          
          ALB_URL="http://${ALB_DNS}:5555"
          
          echo ""
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "üìä DEPLOYMENT SUMMARY"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo ""
          echo "üåê Production URL:"
          echo "   ${ALB_URL}"
          echo ""
          echo "üîç Useful Commands:"
          echo ""
          echo "   # Check service status"
          echo "   aws ecs describe-services --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_SERVICE }} --region ${{ env.AWS_REGION }}"
          echo ""
          echo "   # View logs"
          echo "   aws logs tail /ecs/pardon-simulator --follow --region ${{ env.AWS_REGION }}"
          echo ""
          echo "   # Test health"
          echo "   curl ${ALB_URL}/health"
          echo ""
          echo "üìù Next Steps:"
          echo "  1. Update Vercel: CORAL_SERVER_URL=${ALB_URL}"
          echo "  2. Update Vercel: NODE_ENV=production"
          echo "  3. Test from Next.js backend"
          echo ""
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
      
      - name: ‚ùå On failure - show recent logs
        if: failure()
        run: |
          echo "‚ùå Deployment failed! Fetching recent logs..."
          aws logs tail /ecs/pardon-simulator --since 10m --format short --region ${{ env.AWS_REGION }} 2>&1 | head -100 || true
          echo ""
          echo "üîç Troubleshooting:"
          echo "  1. Check full logs: aws logs tail /ecs/pardon-simulator --follow --region ${{ env.AWS_REGION }}"
          echo "  2. Check service: aws ecs describe-services --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_SERVICE }}"
          echo "  3. Check tasks: aws ecs list-tasks --cluster ${{ env.ECS_CLUSTER }} --service-name ${{ env.ECS_SERVICE }}"

  notify:
    name: Deployment Status
    runs-on: ubuntu-latest
    needs: [build-and-deploy]
    if: always()
    
    steps:
      - name: üì¢ Status notification
        run: |
          if [ "${{ needs.build-and-deploy.result }}" == "success" ]; then
            echo "üéâ ‚úÖ DEPLOYMENT SUCCESSFUL!"
            echo "Your Coral Server is now running on ECS Fargate!"
          else
            echo "‚ùå DEPLOYMENT FAILED"
            echo "Check the logs above for details"
            exit 1
          fi

